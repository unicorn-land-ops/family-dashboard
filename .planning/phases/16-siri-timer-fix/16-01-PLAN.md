---
phase: 16-siri-timer-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/generate-shortcuts.py
  - src/lib/api/timers.ts
autonomous: true
requirements:
  - SIRI-02

must_haves:
  truths:
    - "Siri timer shortcut asks for name and duration separately, then POSTs a real duration_seconds value"
    - "Dashboard correctly calculates countdown from duration_seconds for Siri-created timers"
    - "If a timer arrives with duration_seconds=0 (old shortcut), dashboard parses duration from label as fallback"
    - "Timer propagates to wall display via existing realtime subscriptions"
  artifacts:
    - path: "scripts/generate-shortcuts.py"
      provides: "Two-ask timer shortcut with Calculate action for duration"
      contains: "build_timer_shortcut"
    - path: "src/lib/api/timers.ts"
      provides: "Siri sentinel parsing safety net in fetchActiveTimers"
      contains: "parseSiriTimer"
  key_links:
    - from: "scripts/generate-shortcuts.py"
      to: "Supabase timers table"
      via: "POST /rest/v1/timers with duration_seconds from Calculate action"
      pattern: "duration_seconds.*mv.*calc"
    - from: "src/lib/api/timers.ts"
      to: "src/hooks/useTimers.ts"
      via: "fetchActiveTimers returns timers with real duration_seconds"
      pattern: "parseSiriTimer"
---

<objective>
Fix the Siri timer shortcut to send a real `duration_seconds` value and add a dashboard-side parsing safety net, so that Siri-created timers produce actual countdowns on the wall display.

Purpose: Phase 15 shipped a timer shortcut that sends `duration_seconds=0` as a sentinel, causing timers to instantly expire. This plan fixes both the shortcut (primary) and the dashboard (fallback) so timers work end-to-end.

Output: Updated shortcut generation script + dashboard timer API with sentinel handling. Regenerated signed .shortcut files.
</objective>

<execution_context>
@/Users/joshua/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joshua/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-siri-timer-fix/16-RESEARCH.md
@scripts/generate-shortcuts.py
@src/lib/api/timers.ts
@src/hooks/useTimers.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix timer shortcut to use two asks and compute real duration_seconds</name>
  <files>scripts/generate-shortcuts.py</files>
  <action>
Rewrite `build_timer_shortcut()` in `scripts/generate-shortcuts.py` to use two separate Ask actions instead of one:

1. **Ask 1 (name):** Prompt "What should the timer be called?" with `WFInputType: "Text"`. UUID: `name_ask_uid`.
2. **Ask 2 (minutes):** Prompt "How many minutes?" with `WFInputType: "Number"`. UUID: `mins_ask_uid`.
3. **Calculate:** Use `is.workflow.actions.math` to multiply the minutes input by 60. The Calculate action takes its input implicitly from the previous action's output (the number from Ask 2). Parameters:
   - `WFMathOperand`: 60 (the literal number to multiply by)
   - `WFMathOperation`: `"×"` (the multiply symbol, NOT the word "Multiply")
   - `UUID`: `calc_uid`
4. **Text (JSON):** Build the JSON body using `twv()`:
   - `label` = magic variable from Ask 1 (`mv(name_ask_uid, "Provided Input")`)
   - `duration_seconds` = magic variable from Calculate (`mv(calc_uid, "Calculation Result")`)
   - `created_by` = "siri" (literal)
   - Full template: `'{"label":"'`, mv(name_ask), `'","duration_seconds":'`, mv(calc), `',"created_by":"siri"}'`
5. **POST:** Reuse existing `make_post_action()` helper, same as current.
6. **Show Result:** Confirmation message using Ask 1's name variable.

Keep the same `icon_color` and `icon_glyph` values.

After modifying the script, run it to regenerate and sign shortcuts:
```bash
cd /Users/joshua/Documents/Unicorn.Land/family-dashboard
python3 scripts/generate-shortcuts.py
```

Verify the signed Timer.shortcut file is created in `/tmp/family-dashboard-shortcuts/`.

**Important note on Calculate action:** The `WFMathOperation` value should be the multiplication symbol `"×"` (Unicode multiply sign). If the signing or generation fails, try `"*"` as an alternative. The input to the Calculate action is implicitly the output of the previous action (the Ask for Number result), so no explicit input wiring is needed — just ensure the Calculate action immediately follows the minutes Ask action.
  </action>
  <verify>
1. `python3 scripts/generate-shortcuts.py` runs without error
2. `/tmp/family-dashboard-shortcuts/Timer.shortcut` exists (signed)
3. Inspect the unsigned plist: `python3 -c "import plistlib; d=plistlib.load(open('/tmp/family-dashboard-shortcuts/Timer-unsigned.plist','rb')); actions=d['WFWorkflowActions']; print(len(actions),'actions'); print([a['WFWorkflowActionIdentifier'] for a in actions])"` — should show 6 actions: ask, ask, math, gettext, downloadurl, showresult
4. Verify the JSON text action references two different magic variables (name from ask 1, calculation result from math)
  </verify>
  <done>Timer shortcut has two Ask actions (name + minutes), a Calculate action (minutes * 60), and POSTs `duration_seconds` as a computed integer instead of 0. Signed .shortcut file generated successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Add dashboard-side duration_seconds=0 parsing safety net</name>
  <files>src/lib/api/timers.ts</files>
  <action>
Add a `parseSiriTimer()` function to `src/lib/api/timers.ts` that transforms timers with `duration_seconds === 0` (the old sentinel value) by parsing the duration from the label text. Then apply it in `fetchActiveTimers()`.

1. **Add the function** before `fetchActiveTimers()`:

```typescript
/**
 * Parse duration from label when duration_seconds is 0 (Siri sentinel from old shortcuts).
 * Handles patterns like "pasta 10 minutes", "eggs 5 min", "laundry 30m", "roast 2 hours", "tea 90s".
 */
export function parseSiriTimer(timer: Timer): Timer {
  if (timer.duration_seconds !== 0) return timer;

  const match = timer.label.match(/(\d+)\s*(s(?:ec(?:ond)?s?)?|m(?:in(?:ute)?s?)?|h(?:(?:ou)?rs?)?)/i);
  if (!match) {
    // No parseable duration — default to 5 minutes
    return { ...timer, duration_seconds: 300 };
  }

  const num = parseInt(match[1], 10);
  const unit = match[2].toLowerCase();
  let durationSeconds: number;

  if (unit.startsWith('h')) durationSeconds = num * 3600;
  else if (unit.startsWith('s')) durationSeconds = num;
  else durationSeconds = num * 60;

  const cleanLabel = timer.label.replace(match[0], '').trim() || 'Timer';
  return { ...timer, label: cleanLabel, duration_seconds: durationSeconds };
}
```

2. **Apply in fetchActiveTimers():** Add `.map(parseSiriTimer)` to the data pipeline, BEFORE the filter that checks endTime. Change:
```typescript
return (data ?? []).filter((timer) => {
```
to:
```typescript
return (data ?? []).map(parseSiriTimer).filter((timer) => {
```

This ensures that old Siri timers with `duration_seconds=0` get a real duration before the active-timer filter runs, preventing them from being instantly filtered out as expired.

Do NOT modify `src/hooks/useTimers.ts` — the fix belongs in the API layer so all consumers benefit.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors)
2. `npm run build` succeeds
3. Read `src/lib/api/timers.ts` and confirm:
   - `parseSiriTimer` function exists and is exported
   - `fetchActiveTimers` calls `.map(parseSiriTimer)` before `.filter()`
   - Function handles: minutes ("10 min"), hours ("2 hours"), seconds ("30s"), and missing duration (defaults to 300)
   - Empty label after parsing defaults to "Timer"
  </verify>
  <done>Dashboard handles `duration_seconds=0` sentinel by parsing duration from label text. Old Siri shortcuts that sent 0 will now produce real countdowns. New shortcuts send real values and bypass parsing entirely.</done>
</task>

</tasks>

<verification>
1. **Shortcut generation:** `python3 scripts/generate-shortcuts.py` produces signed Timer.shortcut with 6 actions (2 asks + calculate + text + post + confirm)
2. **TypeScript build:** `npm run build` passes with no errors
3. **End-to-end logic check:** A timer POSTed with `{"label":"pasta","duration_seconds":600}` would produce `endTime = started_at + 600000ms`, giving a 10-minute countdown in `getRemainingSeconds()`
4. **Fallback logic check:** A timer POSTed with `{"label":"pasta 10 minutes","duration_seconds":0}` would be transformed by `parseSiriTimer` to `{label:"pasta", duration_seconds:600}` before filtering
</verification>

<success_criteria>
- Timer shortcut asks for name and minutes separately, computes duration_seconds = minutes * 60, and POSTs it
- Signed Timer.shortcut file generated without errors
- Dashboard parses duration from label when duration_seconds is 0 (safety net for old shortcuts)
- TypeScript builds cleanly with no type errors
- Existing timer functionality (manual timers, realtime sync, priority interrupts) is unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/16-siri-timer-fix/16-01-SUMMARY.md`
</output>
