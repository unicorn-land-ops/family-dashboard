---
phase: 10-hardening-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAutoRefresh.ts
  - src/hooks/useMemoryWatchdog.ts
  - vite.config.ts
autonomous: true
requirements: [DISP-06, DISP-01]

must_haves:
  truths:
    - "Dashboard reloads at 3am even if setTimeout drifts or is throttled"
    - "Dashboard force-reloads if memory usage exceeds 80% of heap limit"
    - "Service worker caches API responses for offline resilience"
    - "New service worker activates immediately via skipWaiting + clientsClaim"
  artifacts:
    - path: "src/hooks/useAutoRefresh.ts"
      provides: "Enhanced auto-refresh with backup 15-minute interval check"
      contains: "backupId"
    - path: "src/hooks/useMemoryWatchdog.ts"
      provides: "Chromium memory pressure detection and forced reload"
      exports: ["useMemoryWatchdog"]
    - path: "vite.config.ts"
      provides: "Workbox runtime caching for weather, transit, countries, fonts APIs"
      contains: "runtimeCaching"
  key_links:
    - from: "src/hooks/useAutoRefresh.ts"
      to: "window.location.reload"
      via: "Backup interval catches missed 3am reload"
      pattern: "setInterval"
    - from: "src/hooks/useMemoryWatchdog.ts"
      to: "performance.memory"
      via: "Chromium-only API checks heap usage every 5 minutes"
      pattern: "performance.*memory"
    - from: "vite.config.ts"
      to: "workbox runtimeCaching"
      via: "VitePWA workbox config array"
      pattern: "runtimeCaching"
---

<objective>
Enhance auto-refresh reliability, add memory pressure detection, and configure service worker runtime caching for API resilience.

Purpose: The dashboard runs 24/7 unattended. The 3am reload must be reliable (backup timer catches drift), memory leaks must be detected before they cause crashes, and API responses should be cached so temporary network outages don't show blank panels.
Output: Enhanced useAutoRefresh, new useMemoryWatchdog hook, and workbox runtime caching in vite.config.ts.
</objective>

<execution_context>
@/Users/joshua/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joshua/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-hardening-polish/10-RESEARCH.md
@src/hooks/useAutoRefresh.ts
@src/lib/constants.ts
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance useAutoRefresh with backup timer and create useMemoryWatchdog</name>
  <files>src/hooks/useAutoRefresh.ts, src/hooks/useMemoryWatchdog.ts, src/App.tsx</files>
  <action>
    1. Enhance `src/hooks/useAutoRefresh.ts`:
       - Keep existing `getNextReloadMs()` and primary `setTimeout` logic unchanged
       - Add a secondary `setInterval` (every 15 minutes / 15 * 60_000 ms) as a backup check:
         - Get current Berlin hour and minute using `toLocaleString('en-US', { timeZone: TIMEZONE })`
         - If `hour === RELOAD_HOUR && minute < 15`, log `[AutoRefresh] Backup check triggered reload` and call `window.location.reload()`
         - This catches cases where the primary setTimeout drifted, was throttled, or the system clock adjusted
       - Clean up both `clearTimeout(timerId)` and `clearInterval(backupId)` in the useEffect cleanup

    2. Create `src/hooks/useMemoryWatchdog.ts`:
       - Export `useMemoryWatchdog(thresholdPercent = 80, checkIntervalMs = 5 * 60_000)` hook
       - In useEffect, check if `performance.memory` exists (Chromium-only API — type it with an intersection type since it's non-standard)
       - If not available (Safari), return early — no-op
       - Set up an `setInterval` that:
         - Reads `usedJSHeapSize` and `jsHeapSizeLimit` from `performance.memory`
         - Calculates `usagePercent = (usedJSHeapSize / jsHeapSizeLimit) * 100`
         - Logs `[MemoryWatchdog] Heap usage: {usagePercent.toFixed(1)}%` at info level
         - If `usagePercent > thresholdPercent`, logs warning and calls `window.location.reload()`
       - Clean up interval on unmount

    3. Wire `useMemoryWatchdog()` in `src/App.tsx`:
       - Import and call `useMemoryWatchdog()` right after the existing `useAutoRefresh()` call
       - Use default parameters (80% threshold, 5-minute check interval)

    NOTE: This task touches App.tsx only to add the one-line `useMemoryWatchdog()` call. Plan 10-01 also modifies App.tsx but touches different sections (error boundary wrapping). Since both plans are Wave 1, if executed sequentially within the wave, the second executor will read the file fresh. If there's a conflict, the error boundary wrapping is structurally separate from the hook call line.
  </action>
  <verify>Run `npm run build` — no TypeScript errors. Grep for `backupId` in useAutoRefresh.ts and `useMemoryWatchdog` in App.tsx to confirm wiring.</verify>
  <done>useAutoRefresh has a 15-minute backup interval that catches missed 3am reloads. useMemoryWatchdog checks heap usage every 5 minutes and force-reloads at 80%. Both hooks are called in App.tsx.</done>
</task>

<task type="auto">
  <name>Task 2: Configure workbox runtime caching for API resilience</name>
  <files>vite.config.ts</files>
  <action>
    Update the VitePWA config in `vite.config.ts`:

    1. Add `skipWaiting: true` and `clientsClaim: true` to workbox options (ensures new service worker activates immediately; the 3am reload picks up fresh code).

    2. Add `runtimeCaching` array to workbox config with these entries:

       - **Google Fonts stylesheets** (`/^https:\/\/fonts\.googleapis\.com\/.*/i`):
         - handler: `StaleWhileRevalidate`
         - cacheName: `google-fonts-stylesheets`

       - **Google Fonts webfont files** (`/^https:\/\/fonts\.gstatic\.com\/.*/i`):
         - handler: `CacheFirst`
         - cacheName: `google-fonts-webfonts`
         - expiration: maxEntries 30, maxAgeSeconds 365 days
         - cacheableResponse: statuses [0, 200]

       - **Open-Meteo weather API** (`/^https:\/\/api\.open-meteo\.com\/.*/i`):
         - handler: `StaleWhileRevalidate`
         - cacheName: `weather-api`
         - expiration: maxEntries 10, maxAgeSeconds 1 hour
         - cacheableResponse: statuses [0, 200]

       - **BVG Transit API** (`/^https:\/\/v6\.bvg\.transport\.rest\/.*/i`):
         - handler: `NetworkFirst`
         - cacheName: `transit-api`
         - expiration: maxEntries 5, maxAgeSeconds 2 minutes
         - networkTimeoutSeconds: 5
         - cacheableResponse: statuses [0, 200]

       - **RestCountries API** (`/^https:\/\/restcountries\.com\/.*/i`):
         - handler: `CacheFirst`
         - cacheName: `countries-api`
         - expiration: maxEntries 250, maxAgeSeconds 7 days
         - cacheableResponse: statuses [0, 200]

    The caching strategies match each API's update frequency: weather is stale-while-revalidate (show cached, fetch fresh), transit is network-first (real-time data, fall back to cache), countries is cache-first (changes rarely).
  </action>
  <verify>Run `npm run build` — build succeeds. Check the generated service worker file in `dist/` for runtimeCaching entries by running `grep -l "weather-api\|transit-api\|countries-api" dist/sw.js` (or similar generated SW filename).</verify>
  <done>vite.config.ts has skipWaiting, clientsClaim, and 5 runtime caching rules. Build produces a service worker that caches API responses with appropriate strategies per API.</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `grep "runtimeCaching" vite.config.ts` confirms runtime caching configured
- `grep "backupId\|setInterval" src/hooks/useAutoRefresh.ts` confirms backup timer
- `grep "useMemoryWatchdog" src/App.tsx` confirms watchdog wired in
- Generated SW in dist/ contains runtime caching routes
</verification>

<success_criteria>
- Auto-refresh has a reliable backup mechanism for the 3am reload
- Memory watchdog detects and reacts to heap pressure on Chromium
- Service worker caches 5 API patterns with appropriate strategies
- skipWaiting + clientsClaim ensure immediate SW activation
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/10-hardening-polish/10-02-SUMMARY.md`
</output>
