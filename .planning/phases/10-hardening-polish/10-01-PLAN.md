---
phase: 10-hardening-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.tsx
  - src/App.tsx
  - src/lib/errorReporting.ts
  - src/components/ErrorFallback.tsx
autonomous: true
requirements: [DISP-06, DISP-03]

must_haves:
  truths:
    - "A crash in one panel does not take down the entire dashboard"
    - "Unhandled JS errors are captured and logged to console with structured context"
    - "React Query cache does not grow unbounded during 24-hour operation"
    - "Global catastrophic failure auto-reloads after 30 seconds"
  artifacts:
    - path: "src/lib/errorReporting.ts"
      provides: "Global error handlers and structured logging"
      exports: ["setupGlobalErrorHandlers"]
    - path: "src/components/ErrorFallback.tsx"
      provides: "Panel-level and global fallback UI components"
      exports: ["PanelFallback", "GlobalFallback", "logError"]
    - path: "src/main.tsx"
      provides: "QueryClient GC tuning and global error handler setup"
      contains: "gcTime"
    - path: "src/App.tsx"
      provides: "Granular error boundaries around each major panel"
      contains: "ErrorBoundary"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/ErrorFallback.tsx"
      via: "ErrorBoundary FallbackComponent prop"
      pattern: "FallbackComponent=.PanelFallback"
    - from: "src/main.tsx"
      to: "src/lib/errorReporting.ts"
      via: "setupGlobalErrorHandlers call before render"
      pattern: "setupGlobalErrorHandlers"
---

<objective>
Add error resilience and memory management to prevent crashes and unbounded memory growth during 24/7 kiosk operation.

Purpose: A crash in any single panel (weather, calendar, timers, etc.) should show a graceful fallback, not a white screen. React Query cache should be garbage-collected to prevent memory growth over hours of operation.
Output: Error boundary components, global error handlers, and tuned QueryClient configuration.
</objective>

<execution_context>
@/Users/joshua/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joshua/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-hardening-polish/10-RESEARCH.md
@src/main.tsx
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-error-boundary and create error handling infrastructure</name>
  <files>src/lib/errorReporting.ts, src/components/ErrorFallback.tsx, src/main.tsx</files>
  <action>
    1. Run `npm install react-error-boundary` to add the single new dependency.

    2. Create `src/lib/errorReporting.ts`:
       - Export `setupGlobalErrorHandlers()` function that registers:
         - `window.onerror` handler logging `{ message, source, lineno, colno, error }` with `[GlobalError]` prefix
         - `window.addEventListener('unhandledrejection', ...)` logging `event.reason` with `[UnhandledRejection]` prefix
       - All logging goes to `console.error` with structured objects (no cloud service needed for a family dashboard)

    3. Create `src/components/ErrorFallback.tsx`:
       - Export `PanelFallback` component (for individual panel boundaries):
         - Shows "Something went wrong" message in a `card-glass p-4 text-center` container
         - Shows a "Try again" button styled with `text-xs text-accent-gold underline` that calls `resetErrorBoundary`
         - Uses FallbackProps type from react-error-boundary
       - Export `GlobalFallback` component (for catastrophic app-level failure):
         - Full-screen centered message: "Dashboard will restart shortly..."
         - Shows `error.message` in text-secondary
         - Uses `useEffect` to schedule `window.location.reload()` after 30 seconds
         - Cleanup clears the timeout
       - Export `logError` function matching react-error-boundary's `onError` signature:
         - Logs `[ErrorBoundary]` with error.message and componentStack

    4. Update `src/main.tsx`:
       - Import and call `setupGlobalErrorHandlers()` BEFORE `createRoot` call
       - Add `gcTime: 10 * 60 * 1000` (10 minutes) to QueryClient defaultOptions.queries
       - Add `staleTime: 60 * 1000` (1 minute) as a sensible default (individual hooks already override)
       - Keep existing `refetchOnWindowFocus: true` and `retry: 3`
  </action>
  <verify>Run `npm run build` — build succeeds with no TypeScript errors. Check that react-error-boundary appears in package.json dependencies.</verify>
  <done>errorReporting.ts exports setupGlobalErrorHandlers, ErrorFallback.tsx exports PanelFallback/GlobalFallback/logError, main.tsx calls setupGlobalErrorHandlers and has gcTime/staleTime on QueryClient.</done>
</task>

<task type="auto">
  <name>Task 2: Wrap App.tsx panels in granular error boundaries</name>
  <files>src/App.tsx</files>
  <action>
    1. Import `ErrorBoundary` from `react-error-boundary`
    2. Import `PanelFallback`, `GlobalFallback`, `logError` from `./components/ErrorFallback`

    3. Wrap the entire App return in a global ErrorBoundary:
       ```
       <ErrorBoundary FallbackComponent={GlobalFallback} onError={logError}>
         <DashboardShell>
           ...existing content...
         </DashboardShell>
       </ErrorBoundary>
       ```

    4. Wrap Header in its own ErrorBoundary:
       ```
       <ErrorBoundary FallbackComponent={PanelFallback} onError={logError}>
         <Header />
       </ErrorBoundary>
       ```

    5. Wrap the main content area's children — each view gets a boundary:
       ```
       {activeView === 'calendar' && (
         <ErrorBoundary FallbackComponent={PanelFallback} onError={logError}>
           <CalendarPanel />
         </ErrorBoundary>
       )}
       ```
       Apply the same pattern to GroceryPanel, TimerPanel, and ChorePanel views.

    6. Wrap sidebar content sections:
       - The priority mode block (TimerPanel compact + GroceryPanel compact) in one boundary
       - The rotation mode block (ContentRotator + RotationIndicator) in one boundary
       - ChorePanel compact in its own boundary

    7. Do NOT wrap StatusBar or MobileNav (pure display, minimal crash risk).

    Boundary strategy: Granular enough that one panel crash isolates, but not so granular that every tiny component has a boundary. One boundary per major "section" of the UI.
  </action>
  <verify>Run `npm run build` — no errors. Visually confirm in code that ErrorBoundary wraps Header, each main view panel, and each sidebar section independently.</verify>
  <done>App.tsx has a global ErrorBoundary (auto-reload on catastrophic failure) and per-panel ErrorBoundaries (show retry button on section failure). A crash in CalendarPanel does not affect the sidebar or header.</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `grep -r "ErrorBoundary" src/App.tsx` shows multiple boundary usages
- `grep -r "gcTime" src/main.tsx` shows 10-minute GC configuration
- `grep -r "setupGlobalErrorHandlers" src/main.tsx` shows global handlers wired up
</verification>

<success_criteria>
- react-error-boundary installed and used in App.tsx with granular panel isolation
- Global error handlers capture window.onerror and unhandledrejection
- QueryClient configured with gcTime (10min) and staleTime (1min) defaults
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/10-hardening-polish/10-01-SUMMARY.md`
</output>
