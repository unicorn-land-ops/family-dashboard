---
phase: 07-timer-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/timers.ts
  - src/lib/sounds.ts
  - src/hooks/useTimers.ts
  - public/sounds/timer-complete.mp3
autonomous: true
requirements: [TIMR-01, TIMR-02, TIMR-03, TIMR-04, TIMR-05]

must_haves:
  truths:
    - "Timer CRUD operations work against Supabase timers table"
    - "useTimers hook provides timers array, addTimer, cancelTimer, dismissTimer"
    - "Realtime subscription invalidates timer cache on remote changes"
    - "Sound alert utility can play timer-complete.mp3"
    - "getRemainingSeconds computes correct countdown from server timestamps"
  artifacts:
    - path: "src/lib/api/timers.ts"
      provides: "fetchActiveTimers, createTimer, cancelTimer, dismissTimer"
      exports: ["fetchActiveTimers", "createTimer", "cancelTimer", "dismissTimer"]
    - path: "src/hooks/useTimers.ts"
      provides: "useTimers hook with query, mutations, realtime, countdown helpers"
      exports: ["useTimers", "getRemainingSeconds", "formatCountdown", "getTimerProgress"]
    - path: "src/lib/sounds.ts"
      provides: "playTimerAlert function"
      exports: ["playTimerAlert"]
    - path: "public/sounds/timer-complete.mp3"
      provides: "Timer completion sound file"
  key_links:
    - from: "src/hooks/useTimers.ts"
      to: "src/lib/api/timers.ts"
      via: "import CRUD functions"
      pattern: "import.*from.*api/timers"
    - from: "src/hooks/useTimers.ts"
      to: "src/hooks/useSupabaseRealtime.ts"
      via: "realtime cache invalidation"
      pattern: "useSupabaseRealtime.*table.*timers"
    - from: "src/lib/sounds.ts"
      to: "public/sounds/timer-complete.mp3"
      via: "HTMLAudioElement loading"
      pattern: "new Audio.*timer-complete"
---

<objective>
Create the timer data layer: Supabase CRUD API functions, useTimers React Query hook with optimistic mutations and realtime sync, countdown computation helpers, and sound alert utility.

Purpose: Establishes the entire data and business logic layer for timers, mirroring the proven useGroceries pattern. All UI components in Plan 02 will consume this single hook.
Output: src/lib/api/timers.ts, src/hooks/useTimers.ts, src/lib/sounds.ts, public/sounds/timer-complete.mp3
</objective>

<execution_context>
@/Users/joshua/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joshua/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-timer-system/07-RESEARCH.md
@.planning/phases/06-grocery-list/06-01-SUMMARY.md

@src/lib/api/groceries.ts
@src/hooks/useGroceries.ts
@src/hooks/useSupabaseRealtime.ts
@src/hooks/useInterval.ts
@src/lib/supabase.ts
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timer CRUD API and sound utility</name>
  <files>src/lib/api/timers.ts, src/lib/sounds.ts, public/sounds/timer-complete.mp3</files>
  <action>
**src/lib/api/timers.ts** — Mirror the groceries.ts pattern exactly. Four async functions:

1. `fetchActiveTimers(): Promise<Timer[]>` — Query `supabase.from('timers').select('*').eq('cancelled', false).order('started_at', { ascending: false })`. After fetching, filter client-side to keep only timers where `endTime > Date.now() - 60_000` (running + recently completed within last 60s for alert display). Return `[]` if `!supabase`.

2. `createTimer(label: string, durationSeconds: number): Promise<void>` — Insert `{ label, duration_seconds: durationSeconds, started_at: new Date().toISOString() }`. Throw if `!supabase`.

3. `cancelTimer(id: string): Promise<void>` — Update `{ cancelled: true }` where `id` matches. Throw if `!supabase`.

4. `dismissTimer(id: string): Promise<void>` — Delete row where `id` matches. Throw if `!supabase`.

Import `supabase` from `'../supabase'` and `Timer` from `'../../types/database'`.

**src/lib/sounds.ts** — Simple HTMLAudioElement wrapper:

- Private module-level `alertAudio: HTMLAudioElement | null = null`
- `getAlertAudio()` lazily creates `new Audio('/sounds/timer-complete.mp3')` with `preload = 'auto'`
- Export `playTimerAlert(): Promise<void>` — resets `currentTime = 0`, calls `audio.play()`, wraps in try/catch to gracefully handle autoplay blocks (log warning, don't throw)

**public/sounds/timer-complete.mp3** — Generate a simple 880Hz (A5) sine wave tone, 1.5 seconds duration, with a 0.3s fade-in and 0.5s fade-out. Use the Web Audio API offline rendering approach via a small inline Node.js script (or use `ffmpeg` if available: `ffmpeg -f lavfi -i "sine=frequency=880:duration=1.5" -af "afade=in:st=0:d=0.3,afade=out:st=1.0:d=0.5" -b:a 128k public/sounds/timer-complete.mp3`). If ffmpeg is not available, create a minimal valid MP3 placeholder file and note it needs replacing. The sound file must exist at `public/sounds/timer-complete.mp3` so the build includes it.
  </action>
  <verify>Run `npx tsc --noEmit` — zero type errors on timers.ts and sounds.ts. Verify `public/sounds/timer-complete.mp3` exists and is >0 bytes.</verify>
  <done>Four timer CRUD functions compile and match the grocery pattern. Sound utility compiles. MP3 file exists in public/sounds/.</done>
</task>

<task type="auto">
  <name>Task 2: Create useTimers hook with countdown helpers</name>
  <files>src/hooks/useTimers.ts</files>
  <action>
Mirror `useGroceries.ts` structure. Single file exports:

**Helper functions (exported, pure):**

1. `getRemainingSeconds(timer: Timer): number` — Compute `endTime = new Date(timer.started_at).getTime() + timer.duration_seconds * 1000`. Return `Math.max(0, Math.ceil((endTime - Date.now()) / 1000))`.

2. `formatCountdown(totalSeconds: number): string` — If `totalSeconds <= 0` return `'0:00'`. Compute hours/minutes/seconds. If hours > 0 return `H:MM:SS`, otherwise `M:SS`. Pad minutes and seconds with leading zero.

3. `getTimerProgress(timer: Timer): number` — Return `1 - remaining / duration_seconds` (0 = just started, 1 = complete). Guard `duration_seconds === 0` returning 1.

**useTimers hook:**

- `useQuery` with key `['timers']`, queryFn `fetchActiveTimers`, `enabled: supabaseEnabled`, `staleTime: 10_000`, `refetchInterval: 30_000`.
- `useSupabaseRealtime({ table: 'timers', onPayload: () => invalidateQueries })`.
- Three `useMutation` calls mirroring groceries pattern:
  - `addTimer({ label, durationSeconds })` — calls `createTimer`, `onSettled` invalidates.
  - `cancel(id)` — optimistic: sets `cancelled: true` in cache. `onMutate` snapshots previous, `onError` rollback, `onSettled` invalidates.
  - `dismiss(id)` — optimistic: filters timer out of cache. Same onMutate/onError/onSettled pattern.
- Compute `activeTimers` from `query.data` filtered to `!cancelled && getRemainingSeconds(t) > 0`.
- Compute `completedTimers` from `query.data` filtered to `!cancelled && getRemainingSeconds(t) <= 0`.

Return object:
```typescript
{
  timers: Timer[],           // all fetched timers (running + recently completed, excludes cancelled)
  activeTimers: Timer[],     // only currently running
  completedTimers: Timer[],  // recently completed (for alert display)
  activeCount: number,
  isLoading: boolean,
  addTimer: (label: string, durationSeconds: number) => void,
  cancelTimer: (id: string) => void,
  dismissTimer: (id: string) => void,
}
```

Import `Timer` from `'../types/database'`, CRUD from `'../lib/api/timers'`, `supabaseEnabled` from `'../lib/supabase'`, `useSupabaseRealtime` from `'./useSupabaseRealtime'`.
  </action>
  <verify>Run `npm run build` — zero errors. Verify `useTimers` exports correctly by checking the build output includes the hook.</verify>
  <done>useTimers hook compiles, exports all timer operations and countdown helpers, mirrors useGroceries pattern with optimistic mutations and realtime sync.</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds with zero errors
- `src/lib/api/timers.ts` has 4 exported functions matching grocery pattern
- `src/hooks/useTimers.ts` has useTimers hook + 3 exported helper functions
- `src/lib/sounds.ts` has playTimerAlert export
- `public/sounds/timer-complete.mp3` exists and is non-empty
- No new dependencies added to package.json
</verification>

<success_criteria>
Timer data layer is complete: CRUD API, React Query hook with optimistic mutations and realtime, countdown computation helpers, and sound alert utility all compile and are ready for UI consumption in Plan 02.
</success_criteria>

<output>
After completion, create `.planning/phases/07-timer-system/07-01-SUMMARY.md`
</output>
