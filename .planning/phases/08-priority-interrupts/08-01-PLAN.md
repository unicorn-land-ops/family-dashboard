---
phase: 08-priority-interrupts
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/usePriorityInterrupt.ts
  - src/hooks/useContentRotation.ts
  - src/App.tsx
  - src/index.css
autonomous: true
requirements:
  - DISP-05

must_haves:
  truths:
    - "When a timer is active, it replaces the content rotation area in the sidebar"
    - "When the grocery list has unchecked items, it replaces the content rotation area in the sidebar"
    - "When both timers and groceries are active, both show in the sidebar (timers above groceries)"
    - "When all timers clear and grocery list is empty, content rotation resumes automatically"
    - "Content rotation pauses (stops cycling) while priority content is displayed"
    - "Transition between priority and rotation modes is smooth (opacity crossfade)"
    - "Mobile layout is completely unaffected (sidebar already hidden in portrait)"
  artifacts:
    - path: "src/hooks/usePriorityInterrupt.ts"
      provides: "Priority state derivation from timer and grocery data"
      exports: ["usePriorityInterrupt"]
    - path: "src/hooks/useContentRotation.ts"
      provides: "Content rotation with pause support"
      contains: "paused"
    - path: "src/App.tsx"
      provides: "Sidebar conditional rendering based on priority mode"
      contains: "priority"
  key_links:
    - from: "src/hooks/usePriorityInterrupt.ts"
      to: "src/App.tsx"
      via: "hook return value drives conditional render"
      pattern: "usePriorityInterrupt"
    - from: "src/hooks/usePriorityInterrupt.ts"
      to: "src/hooks/useContentRotation.ts"
      via: "rotationPaused passed as paused parameter"
      pattern: "rotationPaused"
    - from: "src/App.tsx"
      to: "priority.mode"
      via: "ternary switches between priority panels and ContentRotator"
      pattern: "mode.*===.*priority"
---

<objective>
Implement priority interrupt system for the wall display sidebar. When timers are active or the grocery list has unchecked items, priority content replaces the content rotation area entirely. Content rotation pauses while priority content is showing and resumes with a smooth crossfade when conditions clear.

Purpose: Fulfills DISP-05 -- time-sensitive household content (timers, groceries) takes visual priority over informational rotation (transit, horoscopes, country). The family sees what needs attention instead of rotating fun content.

Output: `usePriorityInterrupt` hook, modified `useContentRotation` with pause support, rewired App.tsx sidebar with mode-based rendering.
</objective>

<execution_context>
@/Users/joshua/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joshua/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-priority-interrupts/08-RESEARCH.md
@src/App.tsx
@src/hooks/useContentRotation.ts
@src/hooks/useInterval.ts
@src/hooks/useTimers.ts
@src/hooks/useGroceries.ts
@src/components/sidebar/ContentRotator.tsx
@src/lib/constants.ts
@src/index.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePriorityInterrupt hook and add pause support to useContentRotation</name>
  <files>src/hooks/usePriorityInterrupt.ts, src/hooks/useContentRotation.ts</files>
  <action>
**Create `src/hooks/usePriorityInterrupt.ts`:**

Define a `SidebarMode` type (`'rotation' | 'priority'`) and a `PriorityState` interface:

```typescript
interface PriorityState {
  mode: SidebarMode;
  showTimers: boolean;
  showGroceries: boolean;
  rotationPaused: boolean;
}
```

The hook accepts three numbers: `activeTimerCount`, `completedTimersCount`, `uncheckedGroceryCount`. Derive:
- `hasActiveTimers = activeTimerCount > 0 || completedTimersCount > 0` (completed timers still show alerts)
- `hasGroceries = uncheckedGroceryCount > 0`
- `hasPriority = hasActiveTimers || hasGroceries`

Add a 500ms debounce when transitioning FROM priority TO rotation mode to prevent flicker when the last timer is dismissed and a new one is quickly set. Use `useState` + `useEffect` with a `setTimeout`. The transition TO priority mode should be instant (no debounce). The debounce only applies to the `mode` field -- `showTimers` and `showGroceries` update instantly.

Return `PriorityState` with `mode`, `showTimers`, `showGroceries`, `rotationPaused` (which follows the debounced `mode`).

Export the `PriorityState` type and the `usePriorityInterrupt` hook.

**Modify `src/hooks/useContentRotation.ts`:**

Add an optional `paused` parameter (default `false`). Pass `paused ? null : ROTATION_INTERVAL_MS` as the delay to `useInterval`. This leverages the existing null-delay pause support in `useInterval.ts`. No other changes needed -- `activeIndex` persists during pause so rotation resumes where it left off (per research recommendation).

Keep the existing `goTo`, `panelCount`, and `panels` return values unchanged.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Confirm usePriorityInterrupt.ts exports the hook and type. Confirm useContentRotation signature accepts `paused?: boolean`.</verify>
  <done>usePriorityInterrupt hook computes priority state from timer/grocery counts with 500ms debounce on exit. useContentRotation accepts paused parameter that stops interval cycling.</done>
</task>

<task type="auto">
  <name>Task 2: Rewire App.tsx sidebar with priority mode switching and crossfade transition</name>
  <files>src/App.tsx, src/index.css</files>
  <action>
**Modify `src/App.tsx`:**

Import `usePriorityInterrupt` from `./hooks/usePriorityInterrupt`.

After the existing `useTimers()` and `useGroceries()` calls, add:
```typescript
const priority = usePriorityInterrupt(activeTimerCount, completedTimers.length, uncheckedCount);
```

Pass `priority.rotationPaused` to `useContentRotation`:
```typescript
const { activeIndex, goTo, panelCount } = useContentRotation(priority.rotationPaused);
```

Replace the entire sidebar `<div className="grid-area-sidebar ...">` contents. Use a conditional render approach (NOT dual-mounted crossfade, because priority panels have different heights than rotation panels):

```tsx
<div className="grid-area-sidebar flex flex-col gap-[clamp(10px,1vw,20px)]">
  {priority.mode === 'priority' ? (
    <div className="sidebar-priority-enter flex flex-col gap-[clamp(10px,1vw,20px)] flex-1">
      {priority.showTimers && <TimerPanel variant="compact" />}
      {priority.showGroceries && <GroceryPanel variant="compact" />}
    </div>
  ) : (
    <div className="sidebar-rotation-enter flex flex-col gap-[clamp(10px,1vw,20px)] flex-1">
      <ContentRotator activeIndex={activeIndex}>
        <TransitPanel />
        <HoroscopePanel />
        <CountryPanel />
      </ContentRotator>
      <RotationIndicator
        activeIndex={activeIndex}
        panelCount={panelCount}
        labels={['Transit', 'Horoscopes', 'Country']}
        onSelect={goTo}
      />
    </div>
  )}
</div>
```

Remove the old conditional timer/grocery rendering that was stacked above the rotator (the `{(activeTimerCount > 0 || completedTimers.length > 0) && <TimerPanel ... />}` and `{uncheckedCount > 0 && <GroceryPanel ... />}` lines). These are now inside the priority branch.

**Add CSS animation in `src/index.css`:**

Add a fade-in animation for smooth mode transitions:

```css
/* Priority interrupt transitions */
@keyframes sidebar-fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.sidebar-priority-enter,
.sidebar-rotation-enter {
  animation: sidebar-fade-in 500ms ease-in-out;
}
```

This gives a smooth fade-in when either mode activates, without the complexity of dual-mounted crossfade containers.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Run `npm run build` -- builds successfully. Visually verify in browser: when no timers/groceries active, sidebar shows ContentRotator. The old stacked layout (timer + grocery above rotator) is gone.</verify>
  <done>Sidebar shows EITHER priority content (timers/groceries) OR content rotation, never both stacked. Transitions fade in smoothly. Mobile layout unchanged (sidebar hidden in portrait). Build passes with no errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no type errors
2. `npm run build` completes successfully
3. No references to the old stacked sidebar pattern remain in App.tsx (timer/grocery panels should only appear inside the priority branch)
4. `useContentRotation` signature includes `paused` parameter
5. `usePriorityInterrupt` exports are importable
6. The sidebar in App.tsx uses `priority.mode` to conditionally render
7. CSS includes `sidebar-fade-in` keyframes and transition classes
8. Mobile layout CSS (`.grid-area-sidebar { display: none }` in portrait) is unchanged
</verification>

<success_criteria>
- Active timers replace content rotation in sidebar (not stacked above it)
- Non-empty grocery list replaces content rotation in sidebar
- When both active, timers show above groceries in priority area
- Content rotation pauses (useInterval receives null delay) during priority mode
- Rotation resumes automatically when all timers clear and groceries empty
- 500ms debounce prevents flicker on priority-to-rotation transition
- Fade-in animation plays on mode switch (500ms ease-in-out)
- Mobile portrait layout is completely unaffected
- TypeScript compiles, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/08-priority-interrupts/08-01-SUMMARY.md`
</output>
