---
phase: 09-chore-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/api/chores.ts
  - src/lib/choreSchedule.ts
  - src/hooks/useChores.ts
autonomous: true
requirements:
  - CHOR-01
  - CHOR-02
  - CHOR-03
  - CHOR-05

must_haves:
  truths:
    - "Chores can be fetched from the database filtered by is_active"
    - "Completions are fetched with a time boundary (8 days) to avoid unbounded growth"
    - "A chore's completion status is derived from schedule type and latest completion timestamp"
    - "Daily chores reset at Berlin midnight, weekly chores reset Monday Berlin time"
    - "Completions sync in realtime across devices"
  artifacts:
    - path: "src/lib/api/chores.ts"
      provides: "Supabase CRUD for chores and chore_completions tables"
      exports: ["fetchChores", "fetchRecentCompletions", "addChore", "completeChore", "uncompleteChore", "deactivateChore"]
    - path: "src/lib/choreSchedule.ts"
      provides: "Pure schedule logic functions"
      exports: ["getPeriodStart", "isChoreCompleted", "getCompletionInfo", "groupByAssignee", "getChoreProgress"]
    - path: "src/hooks/useChores.ts"
      provides: "React Query hook with realtime subscriptions for both tables"
      exports: ["useChores"]
  key_links:
    - from: "src/hooks/useChores.ts"
      to: "src/lib/api/chores.ts"
      via: "query functions"
      pattern: "fetchChores|fetchRecentCompletions"
    - from: "src/hooks/useChores.ts"
      to: "src/lib/choreSchedule.ts"
      via: "derived completion state"
      pattern: "isChoreCompleted|getChoreProgress"
    - from: "src/hooks/useChores.ts"
      to: "useSupabaseRealtime"
      via: "realtime subscriptions on chores and chore_completions"
      pattern: "useSupabaseRealtime.*chore"
---

<objective>
Create the chore data layer: Supabase API functions, pure schedule logic, and the useChores React Query hook with realtime sync.

Purpose: Provides all data operations and derived state for chore tracking. The schedule logic (daily/weekly reset) is the novel piece -- "reset" is derived from comparing completion timestamps against period boundaries, not a database operation.

Output: Three source files forming the complete data layer that UI components will consume.
</objective>

<execution_context>
@/Users/joshua/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joshua/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-chore-tracking/09-RESEARCH.md

@src/lib/api/groceries.ts
@src/hooks/useGroceries.ts
@src/hooks/useTimers.ts
@src/types/database.ts
@src/lib/supabase.ts
@src/hooks/useSupabaseRealtime.ts
@src/lib/calendar/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Chore API module and schedule logic</name>
  <files>src/lib/api/chores.ts, src/lib/choreSchedule.ts</files>
  <action>
Create `src/lib/api/chores.ts` following the exact pattern of `src/lib/api/groceries.ts`:

- `fetchChores()`: Select all from `chores` where `is_active = true`, ordered by `assigned_to` asc then `title` asc. Return empty array if supabase is null.
- `fetchRecentCompletions()`: Select all from `chore_completions` where `completed_at >= 8 days ago` (covers weekly boundary with margin), ordered by `completed_at` desc. Use `new Date(Date.now() - 8 * 86400000).toISOString()` for the boundary. Return empty array if supabase is null.
- `addChore(title: string, assignedTo: string | null, schedule: 'daily' | 'weekly' | 'once')`: Insert into `chores` table. Throw if supabase is null.
- `completeChore(choreId: string, completedBy: string)`: Insert into `chore_completions` table with `chore_id` and `completed_by`. Throw if supabase is null.
- `uncompleteChore(completionId: string)`: Delete from `chore_completions` by id. This handles accidental completion (tap to undo). Throw if supabase is null.
- `deactivateChore(id: string)`: Update `chores` set `is_active = false` where `id` matches. Throw if supabase is null.

Import `supabase` from `'../supabase'` and types from `'../../types/database'`.

Create `src/lib/choreSchedule.ts` with pure functions (no side effects, no imports except date-fns):

- `getPeriodStart(schedule: 'daily' | 'weekly' | 'once'): Date` — Uses `toZonedTime(new Date(), 'Europe/Berlin')` then `startOfDay` for daily, `startOfWeek` with `{ weekStartsOn: 1 }` for weekly, `new Date(0)` for once.
- `isChoreCompleted(chore: Chore, completions: ChoreCompletion[]): boolean` — Finds any completion for this chore_id with completed_at >= getPeriodStart(chore.schedule).
- `getCompletionInfo(chore: Chore, completions: ChoreCompletion[]): ChoreCompletion | undefined` — Returns the matching completion record for display (who did it, when).
- `groupByAssignee(chores: Chore[]): Map<string, Chore[]>` — Groups chores by `assigned_to`, using `'unassigned'` as key for null.
- `getChoreProgress(chores: Chore[], completions: ChoreCompletion[]): { completed: number; total: number }` — Counts how many chores are completed in current period.

Import `startOfDay`, `startOfWeek` from `date-fns`, `toZonedTime` from `date-fns-tz`, and types from `../types/database`.

IMPORTANT: Use `toZonedTime` before `startOfDay`/`startOfWeek` to get Berlin-correct period boundaries. This prevents the pitfall where UTC midnight != Berlin midnight.
  </action>
  <verify>Run `npx tsc --noEmit` — both files compile with no type errors.</verify>
  <done>API module exports 6 CRUD functions matching the groceries pattern. Schedule module exports 5 pure functions with Berlin-timezone-aware period boundaries.</done>
</task>

<task type="auto">
  <name>Task 2: useChores hook with realtime sync and optimistic updates</name>
  <files>src/hooks/useChores.ts</files>
  <action>
Create `src/hooks/useChores.ts` following the `useGroceries` pattern closely but with TWO queries and TWO realtime subscriptions:

**Queries:**
- `useQuery({ queryKey: ['chores'], queryFn: fetchChores, enabled: supabaseEnabled, staleTime: 30_000 })`
- `useQuery({ queryKey: ['chore-completions'], queryFn: fetchRecentCompletions, enabled: supabaseEnabled, staleTime: 30_000 })`

**Realtime:** Two `useSupabaseRealtime` calls:
- `{ table: 'chores', onPayload: () => invalidate(['chores']) }`
- `{ table: 'chore_completions', onPayload: () => invalidate(['chore-completions']) }`

**Mutations:**
1. `addChoreMutation` — calls `addChore()`, no optimistic update (server generates ID), invalidates `['chores']` on settled.
2. `completeChoreMutation` — calls `completeChore(choreId, completedBy)` with optimistic update: insert a fake ChoreCompletion into `['chore-completions']` cache (same pattern as grocery addItem optimistic). Rollback on error.
3. `uncompleteChoreMutation` — calls `uncompleteChore(completionId)` with optimistic update: remove completion from cache. Rollback on error.
4. `deactivateChoreMutation` — calls `deactivateChore(id)` with optimistic update: remove chore from `['chores']` cache. Rollback on error.

**Derived state** (computed from both queries using choreSchedule functions):
- `chores`: raw chore list
- `completions`: raw completion list
- `completedCount`: via `getChoreProgress(chores, completions).completed`
- `totalCount`: via `getChoreProgress(chores, completions).total`
- `isLoading`: either query loading

**Return object:**
```typescript
{
  chores, completions, completedCount, totalCount, isLoading, error,
  addChore: (title, assignedTo, schedule) => ...,
  completeChore: (choreId, completedBy) => ...,
  uncompleteChore: (completionId) => ...,
  deactivateChore: (id) => ...,
}
```

Type all mutation callbacks explicitly (same pattern as useGroceries) to avoid TypeScript inference issues.
  </action>
  <verify>Run `npx tsc --noEmit` — hook compiles. Run `npm run build` — full build succeeds with no errors.</verify>
  <done>useChores hook exports with two queries, two realtime subscriptions, four mutations with optimistic updates, and derived completion counts. Build passes.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- `src/lib/api/chores.ts` exports 6 functions
- `src/lib/choreSchedule.ts` exports 5 pure functions
- `src/hooks/useChores.ts` exports `useChores` returning chores, completions, counts, and mutation functions
</verification>

<success_criteria>
Complete chore data layer: API CRUD, Berlin-timezone-aware schedule logic, and React Query hook with dual realtime subscriptions. All files compile and build passes.
</success_criteria>

<output>
After completion, create `.planning/phases/09-chore-tracking/09-01-SUMMARY.md`
</output>
